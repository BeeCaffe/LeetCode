/***********************************************************************************************************************
 * Created by caffe on 2019/12/11.
 * 62. 不同路径
 * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

    机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

    问总共有多少条不同的路径？
 **********************************************************************************************************************/
/**
 * solution 1 ： 二维动态规划
 * 因为机器人只可以向右边和向下面走，因此可以设置二维数组dp[i][j]来记录到当前格子的所有路径数，显然
 * 当前格子的路径数等于其上面格子和左边格子的路径数之和，依次类推。
 * dp[i][j]=dp[i-1][j]+dp[i][j-1] if i-1>=0 && j-1>=0
 * dp[i][j]=dp[i-1][j] if j==0
 * dp[i][j]=dp[i][j-1] if i==0
 * 时间复杂度：O（n2）
 * 空间复杂度：O（n2）
 */
//执行用时 :0 ms, 在所有 cpp 提交中击败了100.00% 的用户
//内存消耗 :8.6 MB, 在所有 cpp 提交中击败了24.05%的用户
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0]=1;
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(i-1>=0&&j-1>=0) dp[i][j]=dp[i-1][j]+dp[i][j-1];
                else if(j==0&&i-1>=0) dp[i][j]=dp[i-1][j];
                else if(i==0&&j-1>=0) dp[i][j]=dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};